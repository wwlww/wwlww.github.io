[{"title":"c++ cout control","url":"/2022/12/06/cpp-cout-control/","content":"\n简介：介绍利用c++头文件&lt;iomanip&gt;和printf等函数实现输出精度的控制。\n\n\n1.利用&lt;iomanip&gt;中的setprecision函数实现输出精度控制代码：\n#include &lt;iostream>\n#include &lt;iomanip>\nusing namespace std;\nint main()&#123;\n    double a=1234.1234;\n    double b=1.5555;\n    cout&lt;&lt;a&lt;&lt;endl;\n    //cout浮点数默认输出六位有效数字\n    cout&lt;&lt;setprecision(5)&lt;&lt;a&lt;&lt;endl;\n    //设置输出有效数字5位，不包含小数点（不同于setw），并且不是直接截断，而是四舍五入;\n    cout&lt;&lt;a&lt;&lt;endl;\n    //在下一次更改setprecison的值之前，上一次设定的精度仍然有效;\n    cout&lt;&lt;b&lt;&lt;endl;\n    //在该输出精度小于设定精度时不生效;\n    cout&lt;&lt;fixed&lt;&lt;setprecision(5)&lt;&lt;a&lt;&lt;endl;\n    //输入fixed后设定精度改为小数位数，且小数位数不足时补0，四舍五入;\n    cout&lt;&lt;b&lt;&lt;endl;\n    //小数位数的修改仍然有效;\n    return 0;\n&#125;\n\n输出结果：\n1234.12\n1234.1\n1234.1\n1.5555\n1234.12340\n1.55550\n\n2.setw和setfill用法#include &lt;iostream>\n#include &lt;iomanip>\nusing namespace std;\nint main()&#123;\n    double a=1234.1234;\n    double b=1.5555;\n    cout&lt;&lt;setw(5)&lt;&lt;a&lt;&lt;endl;\n    //设置输出5位宽度（包括小数点），默认右对齐，setw只对紧接着的输出产生作用（对在前面的输出也不产生作用），且超过设定位数后输出默认位数;\n    cout&lt;&lt;setw(10)&lt;&lt;b&lt;&lt;endl;\n    //不足设定精度的默认用空格补齐;\n    cout&lt;&lt;setfill('0')&lt;&lt;setw(10)&lt;&lt;b&lt;&lt;endl;\n    //可使用setfill改变补齐字符，不能单独使用，需配合setw使用;\n    return 0;\n&#125;\n\n输出结果：\n1234.12\n    1.5555\n00001.5555\n\n3.printf输出精度控制一般格式：\nprintf(\"格式控制字符串\",输出列表)；\n\n格式控制字符串形式：\n[标志][输出最小宽度][.精度][长度][类型]\n\n类型\nd  以十进制形式输出带符号整数(正数不输出符号) \no  以八进制形式输出无符号整数(不输出前缀 0) \nx,X  以十六进制形式输出无符号整数(不输出前缀 Ox) \nu  以十进制形式输出无符号整数 \nf  以小数形式输出单、双精度实数 \ne,E  以指数形式输出单、双精度实数 \ng,G  以%f 或%e 中较短的输出宽度输出单、双精度实数 \nc  输出单个字符 \ns  输出字符串 \n\n标志：\n-  结果左对齐，右边填空格 \n-  输出符号(正号或负号) \n空格  输出值为正时冠以空格，为负时冠以负号 \n#  对 c,s,d,u类无影响；\n对 o 类,在输出时加前缀 o；对 x 类,在输出时加前缀 0x；\n对 e,g,f 类当结果有小数时才给出小数点\n\n输出位宽：\n用十进制整数来表示输出的最少位数。\n若实际位数多于定义的宽度，则按实际位数输出，\n若实际位数少于定义的宽度则补以空格或 0。\n\n精度：\n精度格式符以“.”开头，后跟十进制整数。本项的意义是：\n如果输出数字，则表示小数的位数；\n如果输出的是字符，则表示输出字符的个数；\n若实际位数大于所定义的精度数，则截去超过的部分。 \n\n长度：\n长度格式符为 h,l 两种，\nh 表示按短整型量输出，l 表示按长整型量输出。\n\n测试代码：\n#include &lt;stdio.h>\n\n\nint main(void) &#123;\n    char s[] = \"abcdefg\";\n    int i = 12345;\n    double d = 123.45678;\n\n\n    printf(\"%s\\n\", s);\n    printf(\"%.*s\\n\", 3, s);\n    printf(\"%#.8x\\n\", s);\n    printf(\"%#p\\n\\n\", s);\n\n\n    printf(\"%d\\n\", i);\n    printf(\"%*d\\n\", 10, i);\n    printf(\"%0*d\\n\\n\", 10, i);\n\n\n    printf(\"%f\\n\", d);\n    printf(\"%.*f\\n\", 3, d);\n    printf(\"%20.10f\\n\", d);\n    printf(\"%*.*f\\n\\n\", 20, 10, d);\n\n\n    return 0;\n&#125;\n\n输出结果：\nabcdefg\nabc\n0x456de280\n0x7ffc456de280\n\n\n12345\n     12345\n0000012345\n\n\n123.456780\n123.457\n      123.4567800000\n      123.4567800000\n","categories":["c++"],"tags":["输出流控制"]},{"title":"github actions部署hexo","url":"/2022/09/29/hexo_actions/","content":"\n简介：在将hexo搭建到github后，我发现每次都要用多个hexo的命令来推送并部署博客，并且原代码的上传也需要额外操作，比较麻烦。但是在浏览多个相关博客内容后，发现相关的教程都比较复杂，不太具备直接copy的能力，于是有此文。利用github action实现一键部署hexo到pages并备份博客代码。  \n\n\n1.创建仓库我们需要两个github仓库来实现博客代码的私有化存储和hexo编译文件的pages布置。  \n另一个应该在部署hexo到github pages时已经建立，仓库名应该为github用户名.github.io  \n2.创建ssh密钥来让本地与github之间实现无密码拉取与推送在终端输入创建ssh密钥的命令：ssh-keygen -t rsa -C &quot;your_email@example.com&quot;  \n\n注意:需要输入的是注册github的邮箱。并且在输入命令后一直回车就行。直到让你输入y&#x2F;n，输入y即可，后面让输入密码不用管，直接回车，否则以后每次拉取都要输入密码。  \n\n成功创建后，windows系统是在C:user/用户名/.ssh/文件夹下产生ssh密钥。其中id_rsa是私钥，id_rsa.pub是公钥。找到刚才建立的博客仓库的设置页面。选择secrets中的action选项。在此添加私钥，起名为HEXO_DEPLOY_KEY将之前创建的id_rsa文件用记事本打开并复制到该密钥下。在github中点击自己的头像，进入settings页面，选择SSH and GPG keys，点击new SSH key,输入公钥。  \n3.设置github action在hexo的主目录下，找到.github/workflows/文件夹，创建deploy.yml，输入如下代码修改后保存。\n\nname: Deploy\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: A job to deploy blog.\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v1\n        with:\n          submodules: true # Checkout private submodules(themes or something else).\n\n      # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)\n      - name: Cache node modules\n        uses: actions/cache@v1\n        id: cache\n        with:\n          path: node_modules\n          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125;\n          restore-keys: |\n            $&#123;&#123; runner.os &#125;&#125;-node-\n      - name: Install Dependencies\n        if: steps.cache.outputs.cache-hit != 'true'\n        run: npm ci\n\n      # Deploy hexo blog website.\n      - name: Deploy\n        id: deploy\n        uses: sma11black/hexo-action@v1.0.3\n        with:\n          deploy_key: $&#123;&#123; secrets.HEXO_DEPLOY_KEY &#125;&#125;//这是之前设置的私钥名\n          user_name: 此处输入github名 # (or delete this input setting to use bot account)\n          user_email: 此处输入github注册邮箱  # (or delete this input setting to use bot account)\n          commit_msg: $&#123;&#123; github.event.head_commit.message &#125;&#125;  # (or delete this input setting to use hexo default settings)\n      # Use the output from the `deploy` step(use for test action)\n      - name: Get the output\n        run: |\n          echo \"$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;\"\n4.测试部署是否成功到此部署完成，进入终端，将代码push到存储博客代码的仓库，当actions检测到master分支接到推送后，会运行deploy，自动将代码编译并部署到github pages。\n\n注意：在hexo的config文件中，deploy部分的repo要设置为github.io仓库的ssh地址，格式为git@github.com:用户名/用户名.github.io.git。  \n\n","categories":["博客"],"tags":["hexo"]},{"title":"quick_sort and merge_sort","url":"/2022/12/10/quick-sort-and-merge-sort/","content":"\n简介：简单记录一下快速排序与归并排序的实C++实现。\n\n\n1.快速排序代码：\n\n#include&lt;iostream>\nusing namespace std;\nint n;\nconst int N=1e6+10;\nint arr[N];\nvoid quickSort(int q[],int l,int r)&#123;//传入待排数组和左右边界\n    if(l>=r) return;\n    //排除空数组和单个数字\n    int i=l-1,j=r+1,x=q[(l+r)/2];\n    //设定双指针的位置，启动位置距离边界为1,x为分界点\n    while(i&lt;j)&#123;\n        do i++;while (q[i]&lt;x);\n    //比较数字与分界点的大小，当i指针运行到大于分界点的数字时停下\n        do j--;while (q[j]>x);\n    //比较数字与分界点的大小，当j指针运行到小于分界点的数字时停下\n        if(i&lt;j) swap(q[i],q[j]);\n    //交换i和j所指的不满足分界条件的数字，使其仍然满足i左边的全小于x，j右边的全大于x\n    &#125;\n    quickSort(q,l,j);\n    quickSort(q,j+1,r);\n    //将数组分为l到j和j+1到r两部分，递归处理两边，分治的思想\n    //注意：当用i指针划分时，应取l到i-1和i-1到r，此时x不能取q[l]，否则会发生死循环，当使用j时同理，不能取q[r]\n&#125;\nint main()&#123;\n    scanf(\"%d\",&amp;n);\n    //读入数组长度\n    for(int i=0;i&lt;n;i++)&#123;\n        scanf(\"%d\",&amp;arr[i]);\n    //正序读入数组\n    &#125;\n   quickSort(arr,0,n-1);\n   //调用快排函数\n    for(int i=0;i&lt;n;i++)&#123;\n        printf(\"%d \",arr[i]);\n    //打印排序后的数组\n    &#125;\n    return 0;\n&#125;\n\n\n2.归并排序代码：\n#include&lt;iostream>\nusing namespace std;\nint n;\nconst int N=1e6+10;\nint arr[N],temp[N];\nvoid merge_sort(int q[],int l,int r)&#123;\n    if(l>=r) return;\n    int mid=l+r>>1;\n    //“>>”为位运算，表示左值除以2的右值次方\n    merge_sort(q,l,mid),merge_sort(q,mid+1,r);\n    //归并排序先递归处理分界点左右两部分\n    int k=0,i=l,j=mid+1;//this i=\"L\",j=mid+\"1\"\n    //设定左右部分的起点\n    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;\n        if(q[i]&lt;=q[j]) temp[k++]=q[i++];\n        else temp[k++]=q[j++];\n    //temp数组中先存入比较中的小值，经过递归处理后，小值都将位于左侧，升序排列\n    &#125;\n    while(i&lt;=mid) temp[k++]=q[i++];\n    //如果比较完成后，左部分仍然有剩余数组，将其直接接到temp数组后(经过前面递归处理部分，内部已经有序，剩下的数组必然为较大部分，排列在后边)\n    while(j&lt;=r) temp[k++]=q[j++];\n    //处理右部分多余的情况\n    for(int i=l,j=0;i&lt;=r;i++,j++) q[i]=temp[j];//this i=\"L\"\n    //将临时数组中的数存入原数组\n&#125;\nint main()&#123;\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n;i++)&#123;\n        scanf(\"%d\",&amp;arr[i]);\n    &#125;\n  merge_sort(arr,0,n-1);\n    for(int i=0;i&lt;n;i++)&#123;\n        printf(\"%d \",arr[i]);\n    &#125;\n    return 0;\n&#125;\n\n\n3.时空复杂度与稳定性\n快速排序是不稳定的，时间复杂度为O（nlogn）到O（n平方）。归并排序是稳定的，时间复杂度为O（nlogn）。注意:稳定是值排序前后，相同数字的位置是否发生变化。快速排序在一趟排序中将数字分割成为独立的两部分，左边一部分小于轴值，右边一部分大于轴值，轴值的选择理论上可以选择数组中的任何一个数组，我们在这里考虑选择第一个数字。然后对两部分序列重复进行上述操作，快速排序可以用递归来完成，其时间复杂度：最好情况O(nlogn)——Partition函数每次恰好能均分序列，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次； 最坏情况O（n^2）,每次划分只能将序列分为一个元素与其他元素两部分，这时的快速排序退化为冒泡排序，如果用数画出来，得到的将会是一棵单斜树，也就是说所有所有的节点只有左（右）节点的树；平均时间复杂度O(nlogn)。\n\n","categories":["算法"],"tags":["排序"]}]
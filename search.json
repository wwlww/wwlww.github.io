[{"title":"c++ cout control","url":"/2022/12/06/cpp-cout-control/","content":"\n简介：介绍利用c++头文件&lt;iomanip&gt;和printf等函数实现输出精度的控制。\n\n1.利用&lt;iomanip&gt;中的setprecision函数实现输出精度控制代码：\n#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;    double a=1234.1234;    double b=1.5555;    cout&lt;&lt;a&lt;&lt;endl;    //cout浮点数默认输出六位有效数字    cout&lt;&lt;setprecision(5)&lt;&lt;a&lt;&lt;endl;    //设置输出有效数字5位，不包含小数点（不同于setw），并且不是直接截断，而是四舍五入;    cout&lt;&lt;a&lt;&lt;endl;    //在下一次更改setprecison的值之前，上一次设定的精度仍然有效;    cout&lt;&lt;b&lt;&lt;endl;    //在该输出精度小于设定精度时不生效;    cout&lt;&lt;fixed&lt;&lt;setprecision(5)&lt;&lt;a&lt;&lt;endl;    //输入fixed后设定精度改为小数位数，且小数位数不足时补0，四舍五入;    cout&lt;&lt;b&lt;&lt;endl;    //小数位数的修改仍然有效;    return 0;&#125;\n\n输出结果：\n1234.121234.11234.11.55551234.123401.55550\n\n2.setw和setfill用法#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;    double a=1234.1234;    double b=1.5555;    cout&lt;&lt;setw(5)&lt;&lt;a&lt;&lt;endl;    //设置输出5位宽度（包括小数点），默认右对齐，setw只对紧接着的输出产生作用（对在前面的输出也不产生作用），且超过设定位数后输出默认位数;    cout&lt;&lt;setw(10)&lt;&lt;b&lt;&lt;endl;    //不足设定精度的默认用空格补齐;    cout&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;setw(10)&lt;&lt;b&lt;&lt;endl;    //可使用setfill改变补齐字符，不能单独使用，需配合setw使用;    return 0;&#125;\n\n输出结果：\n1234.12    1.555500001.5555\n\n3.printf输出精度控制一般格式：\nprintf(&quot;格式控制字符串&quot;,输出列表)；\n\n格式控制字符串形式：\n[标志][输出最小宽度][.精度][长度][类型]\n\n类型\nd  以十进制形式输出带符号整数(正数不输出符号) o  以八进制形式输出无符号整数(不输出前缀 0) x,X  以十六进制形式输出无符号整数(不输出前缀 Ox) u  以十进制形式输出无符号整数 f  以小数形式输出单、双精度实数 e,E  以指数形式输出单、双精度实数 g,G  以%f 或%e 中较短的输出宽度输出单、双精度实数 c  输出单个字符 s  输出字符串 \n\n标志：\n-  结果左对齐，右边填空格 -  输出符号(正号或负号) 空格  输出值为正时冠以空格，为负时冠以负号 #  对 c,s,d,u类无影响；对 o 类,在输出时加前缀 o；对 x 类,在输出时加前缀 0x；对 e,g,f 类当结果有小数时才给出小数点\n\n输出位宽：\n用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或 0。\n\n精度：\n精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。 \n\n长度：\n长度格式符为 h,l 两种，h 表示按短整型量输出，l 表示按长整型量输出。\n\n测试代码：\n#include &lt;stdio.h&gt;int main(void) &#123;    char s[] = &quot;abcdefg&quot;;    int i = 12345;    double d = 123.45678;    printf(&quot;%s\\n&quot;, s);    printf(&quot;%.*s\\n&quot;, 3, s);    printf(&quot;%#.8x\\n&quot;, s);    printf(&quot;%#p\\n\\n&quot;, s);    printf(&quot;%d\\n&quot;, i);    printf(&quot;%*d\\n&quot;, 10, i);    printf(&quot;%0*d\\n\\n&quot;, 10, i);    printf(&quot;%f\\n&quot;, d);    printf(&quot;%.*f\\n&quot;, 3, d);    printf(&quot;%20.10f\\n&quot;, d);    printf(&quot;%*.*f\\n\\n&quot;, 20, 10, d);    return 0;&#125;\n\n输出结果：\nabcdefgabc0x456de2800x7ffc456de28012345     123450000012345123.456780123.457      123.4567800000      123.4567800000\n","categories":["c++"],"tags":["c++ 输出流控制"]},{"title":"github actions部署hexo","url":"/2022/09/29/hexo_actions/","content":"\n简介：在将hexo搭建到github后，我发现每次都要用多个hexo的命令来推送并部署博客，并且原代码的上传也需要额外操作，比较麻烦。但是在浏览多个相关博客内容后，发现相关的教程都比较复杂，不太具备直接copy的能力，于是有此文。利用github action实现一键部署hexo到pages并备份博客代码。  \n\n1.创建仓库我们需要两个github仓库来实现博客代码的私有化存储和hexo编译文件的pages布置。  \n另一个应该在部署hexo到github pages时已经建立，仓库名应该为github用户名.github.io  \n2.创建ssh密钥来让本地与github之间实现无密码拉取与推送在终端输入创建ssh密钥的命令：ssh-keygen -t rsa -C &quot;your_email@example.com&quot;  \n\n注意:需要输入的是注册github的邮箱。并且在输入命令后一直回车就行。直到让你输入y&#x2F;n，输入y即可，后面让输入密码不用管，直接回车，否则以后每次拉取都要输入密码。  \n\n成功创建后，windows系统是在C:user/用户名/.ssh/文件夹下产生ssh密钥。其中id_rsa是私钥，id_rsa.pub是公钥。找到刚才建立的博客仓库的设置页面。选择secrets中的action选项。在此添加私钥，起名为HEXO_DEPLOY_KEY将之前创建的id_rsa文件用记事本打开并复制到该密钥下。在github中点击自己的头像，进入settings页面，选择SSH and GPG keys，点击new SSH key,输入公钥。  \n3.设置github action在hexo的主目录下，找到.github/workflows/文件夹，创建deploy.yml，输入如下代码修改后保存。\nname: Deployon: [push]jobs:  build:    runs-on: ubuntu-latest    name: A job to deploy blog.    steps:      - name: Checkout        uses: actions/checkout@v1        with:          submodules: true # Checkout private submodules(themes or something else).      # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)      - name: Cache node modules        uses: actions/cache@v1        id: cache        with:          path: node_modules          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;          restore-keys: |            $&#123;&#123; runner.os &#125;&#125;-node-      - name: Install Dependencies        if: steps.cache.outputs.cache-hit != &#x27;true&#x27;        run: npm ci      # Deploy hexo blog website.      - name: Deploy        id: deploy        uses: sma11black/hexo-action@v1.0.3        with:          deploy_key: $&#123;&#123; secrets.HEXO_DEPLOY_KEY &#125;&#125;//这是之前设置的私钥名          user_name: 此处输入github名 # (or delete this input setting to use bot account)          user_email: 此处输入github注册邮箱  # (or delete this input setting to use bot account)          commit_msg: $&#123;&#123; github.event.head_commit.message &#125;&#125;  # (or delete this input setting to use hexo default settings)      # Use the output from the `deploy` step(use for test action)      - name: Get the output        run: |          echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot;\n4.测试部署是否成功到此部署完成，进入终端，将代码push到存储博客代码的仓库，当actions检测到master分支接到推送后，会运行deploy，自动将代码编译并部署到github pages。\n\n注意：在hexo的config文件中，deploy部分的repo要设置为github.io仓库的ssh地址，格式为git@github.com:用户名/用户名.github.io.git。  \n\n","categories":["建站"],"tags":["博客 GitHub hexo"]}]